using BookingFluentAPI_V2.Infrastructure;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.Extensions.Configuration;

var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .Build();

var connectionString = configuration.GetConnectionString("DatabaseConnection");

var options = new DbContextOptionsBuilder<ApplicationDbContext>()
    .UseSqlServer(connectionString)
    .Options;

using var context = new ApplicationDbContext(options);




//Задание:
//Создай пять сущностей: Booking, Customer, Room, Payment, Discount, и RoomMaintenance.
//Свяжи сущности с помощью Fluent API, реализуя несколько типов связей:
//один - ко - многим, многие - ко - многим, и один-к-одному.

//Требования:
//У клиента может быть несколько бронирований, но каждое бронирование привязано только к одному клиенту.
//Каждая комната может быть забронирована несколько раз, но одно бронирование связано только с одной комнатой.
//У каждого бронирования может быть несколько платежей, но один платеж относится только к одному бронированию.
//Одно бронирование может иметь несколько скидок, но одна скидка может применяться к разным бронированиям.
//Каждая комната может быть на техническом обслуживании (техническое обслуживание — это отдельная сущность RoomMaintenance).
//Комната не может быть забронирована, если она на техническом обслуживании (проверка этого условия должна быть выполнена в базе данных).

//Для Room задай следующее обязательное поведение:
//Поле RoomNumber(номер комнаты) должно быть уникальным.
//Поле IsAvailable должно обновляться автоматически: если в комнате есть активное техническое обслуживание, комната недоступна для бронирования.

//Для RoomMaintenance задай следующие поля:
//StartDate — дата начала обслуживания (обязательное поле).
//EndDate — дата окончания обслуживания (может быть null, если обслуживание еще не завершено).
//Description — описание обслуживания (максимум 200 символов).

//Добавь обязательное поведение для RoomMaintenance:
//Не должно быть пересечения периодов обслуживания для одной комнаты (проверка на уровне базы данных).
//Поле EndDate может быть null только если обслуживание еще не завершено. Когда EndDate задано, оно должно быть больше StartDate.

//Для Payment задай следующие поля:
//PaymentDate — обязательное.
//Amount — сумма платежа (обязательное поле, положительное значение).
//PaymentMethod — строковое поле, содержащее информацию о методе оплаты (максимум 20 символов).

//Для Discount задай следующие поля:
//DiscountPercentage — процент скидки (обязательное поле, значение от 0 до 100).
//Description — описание скидки (максимум 100 символов).
//IsActive — флаг активности скидки.

//Связи между сущностями:
//Один Customer может иметь много Bookings (связь "один ко многим").
//Один Booking связан с одной Room, но комната может быть забронирована несколько раз (связь "один ко многим").
//Один Booking может иметь несколько Payments, но каждый Payment связан только с одним Booking (связь "один ко многим").
//Один Booking может иметь несколько Discounts, и одна Discount может быть применена к разным Bookings (связь "многие ко многим").
//Один RoomMaintenance может быть связан только с одной Room (связь "один к одному").
//RoomMaintenance может быть связано только с одной комнатой, и эта комната должна быть "занята" на период обслуживания.


//Добавь ограничение на уникальность поля RoomNumber в таблице Room через Fluent API.
//Убедись, что поле Amount в сущности Payment принимает только положительные значения.
//Настрой индексы и уникальные ограничения:
//Для RoomMaintenance, не допускай пересечения периодов обслуживания для одной комнаты.
//Убедись, что Discount не может быть применена дважды к одному бронированию.
//Убедись, что для каждого Booking не может быть более одной активной скидки одновременно.

//Дополнительные требования:
//Реализуй бизнес-логику для проверки доступности комнаты для бронирования:
//Если на момент бронирования комната находится на техническом обслуживании, бросай исключение.
//Добавь логику обновления флага IsAvailable для комнаты: если в таблице RoomMaintenance для этой комнаты есть активная запись без EndDate, IsAvailable должно быть false.
//Настрой Cascade Delete для сущностей RoomMaintenance: при удалении комнаты удаляй также все связанные записи обслуживания.
//Реализуй проверку на уровне базы данных, чтобы не допускать пересечения периодов обслуживания через CHECK CONSTRAINT или TRIGGERS.
//Подсказки:
//Используй методы HasKey(), HasIndex().IsUnique(), HasMany(), HasOne(), HasCheckConstraint(), HasData() и UsingEntity() для реализации всех ограничений и связей.
//Используй Fluent API для создания всех индексов, ограничений и проверок в базе данных.
//Для проверки пересечения дат можно использовать SQL-функции или ограничительные индексы.
//Ожидаемый результат:
//Связи между сущностями настроены с использованием Fluent API.
//Уникальные индексы и ограничения для сущностей настроены.
//Все связи "один ко многим", "один к одному", "многие ко многим" реализованы корректно.
//Бизнес-логика проверок доступности комнат реализована.
//Запрещены пересекающиеся периоды обслуживания для комнат.
//Это задание требует более сложного управления связями между сущностями, использования каскадных удалений, бизнес-логики для работы с доступностью комнаты, а также настройки ограничений на уровне базы данных через Fluent API.